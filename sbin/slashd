#!/usr/bin/perl -w
# This code is a part of Slash, and is released under the GPL.
# Copyright 1997-2001 by Open Source Development Network. See README
# and COPYING for more information, or see http://slashcode.com/.
# $Id$

###############################################################################
# slashd - the primary "daemon" that runs various tasks and generates
# static pages 
###############################################################################

use sigtrap;
use strict;
use Carp;
use Date::Manip;
use File::Basename;
use File::Path;
use LWP::UserAgent;
use HTTP::Request;
use Time::Local;
use URI::Escape;
use XML::Parser::Expat;
use XML::RSS 0.95;
use Schedule::Cron;

use Slash;
use Slash::Utility;

use vars qw( %task );

my $virtual_user = $ARGV[0];
createEnvironment($ARGV[0]);
my $constants = getCurrentStatic();
my $slashdb = getCurrentDB();
my $user = getCurrentUser();

sub END { Carp::cluck("why am I here?") }

sub slashdPid {
	local *PID;
	open PID,">$constants->{logdir}/slashd.pid"
		or die "Can't open $constants->{logdir}/slashd.pid: $!";
	print PID $$;
	close PID;
}

sub slashdLogInit {
	my $ld = $constants->{logdir};
	mkpath "$ld/", 0, 0755;
	my $file = "$ld/slashd.log";
	open(STDERR, ">>", $file) or die "Can't append STDERR to $file: $!";
}

sub slashdLog {
	local *LOG;
	my $file = "$constants->{logdir}/slashd.log";
	open(LOG, ">>", $file) or die "Can't append to $file: $!\nmsg: @_\n";
	print LOG localtime() . "\t", join("\t", @_), "\n";
	close LOG;
}

sub slashdLogDie {
	my $err = join(" ", @_);
	slashdLog($err);
	die $err;
}

main();

sub init_cron {
	sub null_dispatcher { die "null_dispatcher called, there must be a bug" }
	my $cron = Schedule::Cron->new(\&null_dispatcher);
	return $cron;
}

sub process_tasks {
	my($cron) = @_;
	%task = ( );

	# "require" all the task files -- each will put its info into $task{"filename.pl"}

	my %success = my %failure = ( );
	my $dir = "$constants->{datadir}/tasks";
	if (!-e $dir or !-d _ or !-r _) {
		slashdLogDie("could not process task files in $dir, not readable to $>");
	}

	# Go through the files and require them all.  Each file will store its
	# data and code in %task and execute any necessary initialization.  We also
	# do some rudimentary checks of whether an attacker with guest access on
	# this system could be feeding us bad code (the better solution, of course,
	# is not to let attackers have local guest access).

	my $I_WANT_SLASHD_TO_BE_A_SILLY_LOCAL_SECURITY_HOLE = 0;
	if (not $I_WANT_SLASHD_TO_BE_A_SILLY_LOCAL_SECURITY_HOLE
		and (stat $dir)[2] & 002) {
		slashdLogDie("you really don't want me to use task files",
			"from a directory that's world-writable: $dir");
	}
	my @files =
		sort
		grep { -e $_ and -f _ and -r _ }
		glob "$dir/[a-zA-Z0-9_-][a-zA-Z0-9_-]*.pl";
	for my $fullname (@files) {
		if (not $I_WANT_SLASHD_TO_BE_A_SILLY_LOCAL_SECURITY_HOLE
			and (stat $fullname)[2] & 002) {
			slashdLogDie("you really don't want me to use a task file",
				"that's world-writable: $fullname");
		}
		my $file = basename($fullname);
		my $ok = 0;
		eval { $ok = require $fullname; };
		if ($@) {
			slashdLog("requiring '$fullname' raised exception: $@");
			$ok = 0;
		}
		if ($!) {
			slashdLog("requiring '$fullname' caused error: $!");
			$ok = 0;
		}
		if (!$task{$file}{timespec}) {
			slashdLog("'$fullname' did not set timespec properly");
			$ok = 0;
		}
		if (!$task{$file}{code} or ref $task{$file}{code} ne 'CODE') {
			slashdLog("'$fullname' did not set code properly");
			$ok = 0;
		}
		if ($ok) {
			$success{$file} = 1;
		} else {
			delete $task{$file} if $task{$file};
			$failure{$file} = 1;
		}
	}

	# Log success and failure, and if no successes, abort with die()

	slashdLog(
		  "processed $dir; "
		. (scalar keys %success) . " successful"
		. (
			%failure
			?  " (" . join(" ", sort keys %success) . ")"
			: ""
		)
		. "; "
		. (scalar keys %failure) . " failed ("
		. join(" ", sort keys %failure)
		. ")"
	);
	if (!%task) {
		slashdLogDie("aborting: no files successfully processed from $dir");
	}

	# The appropriate data is in $task{"filename.pl"} -- write it all into
	# the $cron object.

	$cron->clean_timetable;
	for my $file (sort keys %task) {
		$task{$file}{entry} = $cron->add_entry($task{$file}{timespec}, $task{$file}{code});
	}
	$cron->build_initial_queue;

}

sub db_time {
	return UnixDate(ParseDate($slashdb->getTime()), "%s");
}

# NOTE: This logic is busted. What we really need to do is keep a list
# that orders each task, and pop executed tasks from the front and then
# reorder them appropriately. The way this code runs now, a 2-minute
# task executed at 0:10 means a second task at 0:11 will never run.
# Fix it.  XXX  -Jamie 2001/05/10

sub get_next_event {
	my($cron) = @_;

	# Get the DB's idea of what the current time is (should be GMT).
	my $time = db_time();

	my $min_time = 2**32-1;
	my $min_file = '';
	for my $file (keys %task) {
		my $timespec = $task{$file}{timespec};
		my $entry_time = $cron->get_next_execution_time($timespec, $time);
		if ($entry_time < $min_time) {
			$min_time = $entry_time;
			$min_file = $file;
		}
	}
	return ($min_time, $task{$min_file}{code});
}

sub wait_until {
	my($until_time) = @_;
	while ((my $cur_time = db_time()) < $until_time) {
		my $sleep_duration = $until_time - $cur_time;
		$sleep_duration = 1 if $sleep_duration < 1;
		sleep $sleep_duration;
	}
}

sub main {
	slashdLogInit();
	slashdPid();
	slashdLog("Starting up Slashd with pid $$");

	my $cron = init_cron();
	process_tasks($cron);
	while (1) {
		my($until_time, $subref) = get_next_event($cron);
		wait_until($until_time);
		&$subref($virtual_user, $constants, $slashdb, $user);
		sleep 2; # at least this much pause between tasks
	}
}

# prog2file is called by freshenup.pl and p2f_hof_topics.pl, as well as
# any other plugins you write yourself

sub prog2file {
	my($command, $arguments, $f) = @_;
	return 0 unless -e $command and -r _ and -x _;
	my $exec = "$command virtual_user=$virtual_user $arguments";
	my $data = `$exec`;
	slashdLog($exec);
	my $dir = dirname($f);
	mkpath($dir, 0, 0755) unless -e $dir;
	if (length($data) > 0) {
		local *F;
		open F, ">", $f or die "Can't open $f: $!";
		print F $data;
		close F;
		return 1;
	} else {
		return 0;
	}
}

