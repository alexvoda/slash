#!/usr/bin/perl -w

###############################################################################
# slashd - the primary "daemon" that runs various tasks and generates
# static pages 
#
# Copyright (C) 1997 Rob "CmdrTaco" Malda
# malda@slashdot.org
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
#  $Id$
###############################################################################
use sigtrap;
use strict;
use vars '$I';
use Carp;
use File::Basename;
use File::Path;
use LWP::UserAgent;
use HTTP::Request;
use URI::Escape;
use XML::RSS;

use Slash;
use Slash::DB;
use Slash::Utility;

#*I = getSlashConf();
my $slashdb = Slash::DB->new('slash');
$I = $slashdb->getSlashConf();
my $totalChangedStories = 1;

sub END { Carp::cluck("why am I here?") }

sub slashdPid {
	local *PID;
	open PID,">$I->{datadir}/logs/slashd.pid"
		or die "Can't open $I->{datadir}/logs/slashd.pid: $!";
	print PID $$;
	close PID;
}

sub slashdLog {
	local *LOG;
	my $dir = "$I->{datadir}/logs";
	open LOG, ">>$dir/slashd.log"
		or die "Can't append to $dir/slashd.log: $!";
	print LOG localtime() . "\t", join("\t", @_), "\n";
	close LOG;
}

sub copy {
	my($from, $to) = @_;
	# Make sure that $to exists

	my $t = $to;
	$t =~ s|(.*)/(.*)|$1|;
	my @dirs = split m/\//, $t;

	my $d;
	foreach (@dirs) {
		$d .= "/$_";
		slashdLog "mkdir $d";
		mkdir $d, 0755;
	}

	local(*FROM, *TO);
	open FROM, $from or die "Can't open $from: $!";
	open TO, ">>$to" or die "Can't append to $to: $!";
	while (<FROM>) { print TO }
	close FROM;
	close TO;
}


sub xmlEncodeStr  {
	my $s = shift;
	$s =~ s/&/&amp;/g;
	$s =~ s/</&lt;/g;
	$s =~ s/>/&gt;/g;

	return $s;
}

sub geturl {
	my $ua = new LWP::UserAgent;
	my $request = new HTTP::Request('GET', $_[0]);

	my $result = $ua->request($request);

	if ($result->is_success) {
		return $result->content;
	} else {
		return 0;
	}
}


sub prog2file {
	my($c, $f) = @_;
	my $d = `$c`;
	my $dir = dirname($f);
	mkpath($dir, 0, 0755) unless -e $dir;
	if (length($d) > 0) {
		local *F;
		open F, ">$f" or die "Can't open $f: $!";
		print F $d;
		close F;
		return "1";

	} else {
		return "0";
	}
}

sub moveImages {
	if (opendir DIR, "/tmp/slash") {
		my @files = readdir(DIR);
		foreach my $old (@files) {
			my $new = "$I->{basedir}/$old";
			$new =~ s|~|/|g;
			if (substr($old, 0, 1) ne ".") {
				copy("/tmp/slash/$old", $new);
				unlink "/tmp/slash/$old"
					or warn "Can't unlink /tmp/slash/$old: $!";
			}
		}
	}
}

#################################
sub setheadertopics {
	my $stories = getNewStoryTopic();
	my($x, $r, $t);

	for (@$stories) {
		last if $x < 5;
		local $_ = $t;
		if (! /$_->{'tid'}/) {	
			$r .= <<EOT;
	<TD><A HREF="$I->{rootdir}/search.pl?topic=$_->{'tid'}"><IMG
		SRC="$I->{imagedir}/topics/$_->{'image'}" WIDTH="$_->{'width'}" HEIGHT="$_->{'height'}"
		BORDER="0" ALT="$_->{'alttext'}"></A>
	</TD>

EOT
			$t .= $_->{'tid'};
			$x++;
		}
	}
	$slashdb->setBlock('topic', {block => $r});
}

#################################
sub getminute {
	my($sec, $min) = gmtime;
	return $min;
}

#################################
sub save2file {
	my($f, $d) = @_;
	local *FH;
	open FH,">$f" or die "Can't open $f: $!";
	print FH $d;
	close FH;
}

#################################
sub newmotd {
	return unless -x '/usr/games/fortune';
	chomp(my $t = `/usr/games/fortune -s`);
	$slashdb->setBlock('motd', {block => $t}) if $t;
}



#################################
sub sectionHeaders {
	my $section = shift;
	local *FH;

	$I->{F}{ssi} = 1;
	open FH,">$I->{basedir}/$section/slashhead.inc"
		or die "Can't open $I->{basedir}/$section/slashhead.inc: $!";
	*STDOUT = *FH;
	header("", $section, "thread");
	close FH;

	$I->{F}{ssi} = 0;
	open FH, ">$I->{basedir}/$section/slashfoot.inc"
		or die "Can't open $I->{basedir}/$section/slashfoot.inc: $!";
	*STDOUT = *FH;
	footer();
	close FH;

	$I->{F}{ssi} = 1;
	open FH, ">$I->{basedir}/$section/slashhead_F.inc"
		or die "Can't open $I->{basedir}/$section/slashhead_F.inc: $!";
	*STDOUT = *FH;
	header("", $section, "flat");
	close FH;

	$I->{F}{ssi} = 0;
	open FH, ">$I->{basedir}/$section/slashfoot_F.inc"
		or die "Can't open $I->{basedir}/$section/slashfoot_F.inc: $!";
	*STDOUT = *FH;
	footer();
	close FH;
}

#################################
sub newfooter {
	local *FH;
	local *SO = *STDOUT;

	sectionHeaders("");
	my $sections = $slashdb->getSections('section');
	for(@$sections) {
		my ($section) = @$_;
		mkdir "$I->{basedir}/$section", 0755;
		sectionHeaders($section);
	}

	*STDOUT = *SO;
}


#################################
sub newrdf {
	my $section = shift;
	my $storis_and_topics = $slashdb->getBackendStories($section);
	my $rss = XML::RSS->new(
		version => '0.9',
		$I->{rdfencoding} ? (encoding => $I->{rdfencoding}) : ()
	);

	my $SECT = getSection($section);
	$SECT->{title} = "$I->{sitename}: $SECT->{title}" unless $SECT->{isolate};

	my @fs = (xmlEncodeStr($SECT->{title}),
		$section ? "/index.pl?section=$section" : '',
		xmlEncodeStr($I->{sitename})
	);

	$rss->channel(
		title		=> xmlEncodeStr($SECT->{title}),
		'link'		=> $I->{absolutedir} . ($section ? "/index.pl?section=$section" : '/'),
#		language	=> $I->{rdflanguage},
		description	=> $I->{slogan},
	);

	$rss->image(
		title		=> xmlEncodeStr($I->{sitename}),
		url		=> $I->{rdfimg},
		'link'		=> $I->{absolutedir} . '/',
	);


	for my $section (@$storis_and_topics) {
		$rss->add_item(
			title	=> xmlEncodeStr($section->{title}),
			'link'	=> "$I->{absolutedir}/article.pl?sid=$section->{sid}",
		);
	}

	(my $file = $section || lc $I->{sitename}) =~ s/\W+//g;
	$rss->save("$I->{basedir}/$file.rdf");
}

#################################
sub newwml {
	my $section = shift;
	my $storis_and_topics = $slashdb->getBackendStories($section);

	my $x = <<EOT;
<?xml version="1.0"?>
<!DOCTYPE wml PUBLIC "-//PHONE.COM//DTD WML 1.1//EN" "http://www.phone.com/dtd/wml11.dtd" > 
<wml>
                        <head><meta http-equiv="Cache-Control" content="max-age=3600" forua="true"/></head>
<!--  Dev  -->

<!-- TOC -->
<card title="$I->{sitename}" id="$I->{sitename}">
<do label="Home" type="options">
<go href="/index.wml"/>
</do>
<p align="left"><b>$I->{sitename}</b>
<select>
EOT

        my $z = 0;
        my $body;
				for my $section (@$storis_and_topics) {
					$x .= qq|<option title="View" onpick="/wml.pl?sid=$section->{sid}">| .
						xmlEncodeStr(stripByMode($section->{title})) . 
						"</option>\n";
					$z++;
        }     

        $x .= <<EOT;
</select>
</p>
</card>
</wml>
EOT

	(my $file = $section || lc $I->{sitename}) =~ s/\W+//g;
        save2file("$I->{basedir}/$file.wml", $x);
}

#################################
sub newxml {
	my $section = shift;
	my $storis_and_topics = $slashdb->getBackendStories($section);

	my $x = <<EOT;
<?xml version="1.0"?><backslash
xmlns:backslash="$I->{rootdir}/backslash.dtd">

EOT

	for my $section (@$storis_and_topics) {
		$x.= sprintf <<EOT, xmlEncodeStr($section->{title}), xmlEncodeStr($section->{dept});
	<story>
		<title>%s</title>
		<url>$I->{rootdir}/article.pl?sid=$section->{sid}</url>
		<time>$section->{'time'}</time>
		<author>$section->{aid}</author>
		<department>%s</department>
		<topic>$section->{tid}</topic>
		<comments>$section->{commentcount}</comments>
		<section>$section->{section}</section>
		<image>$section->{image}</image>
	</story>

EOT
	}

	$x .= "</backslash>\n";
	(my $file = $section || lc $I->{sitename}) =~ s/\W+//g;
	save2file("$I->{basedir}/$file.xml", $x);
}


#################################
sub openBackend {
	newxml();
	newrdf();
	newwml();
	my $sections = $slashdb->getSections('section');
	for(@$sections){
		my ($section) = @$_;
		newxml($section);
		newrdf($section);
	}
}

#################################
sub makeDir {
	my($section, $sid) = @_;

	my $monthid = substr($sid, 3, 2);
	my $yearid = substr($sid, 0, 2);
	my $dayid = substr($sid, 6, 2);

	mkpath "$I->{basedir}/$section/$yearid/$monthid/$dayid", 0, 0755;
}

#################################
# This is the normal, every 60 seconds stuff
sub freshenup {
	moveImages();

	my %updates;
	my $stories = $slashdb->getStoriesForSlashdb();
	my @updatedsids;

	for (@$stories){
		my($sid, $title, $section) = @$_;
		slashdLog("Updating $title $sid");
		$updates{$section} = 1;
		makeDir($section, $sid);
		$totalChangedStories++;

		if (prog2file("$I->{basedir}/article.pl sid=$sid\\\&ssi=yes\\\&mode=thread",
			"$I->{basedir}/$section/$sid.shtml")) {

			# Don't need this any more.
			prog2file("$I->{basedir}/article.pl sid=$sid\\\&ssi=yes\\\&mode=flat",
				"$I->{basedir}/$section/$sid"."_F.shtml");

			push @updatedsids, $sid;
		} else {
			slashdLog("Trouble Updating $sid");
		}
	}


	$slashdb->setStoryIndex(@updatedsids);

	my $x = 0;
	$stories = $slashdb->getStoriesForSlashdb();
	for (@$stories){
		my($sid, $title, $section) = @$_;
		$x++;
		$updates{$section} = 1;
		unlink "$I->{basedir}/$section/$sid.shtml"
			or warn "Can't unlink $I->{basedir}/$section/$sid.shtml: $!";
		unlink "$I->{basedir}/$section/${sid}_F.shtml"
			or warn "Can't unlink $I->{basedir}/$section/${sid}_F.shtml: $!";
		$slashdb->deleteStoryAll($sid);
		slashdLog("Deleting $sid");
	}

	my($w) = $slashdb->getVar("writestatus");

#	if ($updates{articles} ne "" || $w ne "0") {
		$slashdb->setVar("writestatus", "0");
		prog2file("$I->{basedir}/index.pl ssi=yes", "$I->{basedir}/index.shtml");
		# prog2file("$I->{basedir}/index.pl ssi=yes\\\&mode=flat","$I->{basedir}/index_F.shtml");
#	}

	foreach my $key (keys %updates) {
		next unless $key;
		prog2file("$I->{basedir}/index.pl ssi=yes\\\&section=$key",
			"$I->{basedir}/$key/index.shtml");
		# prog2file("$I->{basedir}/index.pl ssi=yes\\\&mode=flat\\\&section=$key","$I->{basedir}/$key/index_F.shtml");
	}
}

#######################################
sub writePollBooth {
	$I->{currentSection} = "redhat";
	my $poll = pollbooth("", "rh");
	$poll = qq!\n<FONT FACE="$I->{mainfontface}" SIZE="1">$poll</FONT>\n!;
	save2file("$I->{basedir}/pollbooth.html", $poll);
	$I->{currentSection} = "";
}


main();

sub main {
	mkpath "$I->{datadir}/logs/", 0, 0755;
	open STDERR, ">> $I->{datadir}/logs/slashd.log"
		or die "Can't open STDERR to $I->{datadir}/logs/slashd.log: $!";

	slashdPid();
	slashdLog("Starting up Slashd with pid $$");

	my $last = my $modlast = 0;
	while (1) {
		freshenup();
		print "Got out of freshen \n";
		if ((time - $last) > 60 * 60 ) { # Every Hour
			slashdLog("Doing Hourly Update");
			newfooter();
			setheadertopics();
			openBackend();


			newmotd();
			system("$I->{datadir}/portald &");
			sleep(60 * 2);

			my($today) = $slashdb->getTime();
			my($yesterday) = $slashdb->getVars("today");

			if ($today ne $yesterday) {
				$slashdb->setVar("today", $today);
				slashdLog("It's Tomorrow: Run Slashd daily Voodoo");
				system("$I->{datadir}/dailyStuff &");
			}
			$last = time;

		} elsif ((time - $modlast) > (60 * 60 * 2)) { # Every 2 Hours
			slashdLog("Running Moderatord");
			system("$I->{datadir}/moderatord");
			prog2file("$I->{basedir}/hof.pl ssi=yes", "$I->{basedir}/hof.shtml");
			prog2file("$I->{basedir}/topics.pl ssi=yes", "$I->{basedir}/topics.shtml");
			prog2file("$I->{basedir}/cheesyportal.pl ssi=yes",
				"$I->{basedir}/cheesyportal.shtml");
			$modlast = time;
		}

		sleep(60 * $I->{updatemin}); # Sleep for 5 minutes
	}
}

__END__
