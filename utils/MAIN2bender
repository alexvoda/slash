#!/usr/bin/perl

use DBI;
use Getopt::Std;

$0 =~ /[^\/]+$/;
my $PROGNAME = $1;

my(%optsi, %aidCache);
getopts('P:s:d:o:?h', \%opts);
# Blindly show usage under the usual conditions.
usage() if $opts{'?'} || $opts{h} || !keys(%opts);
# Perform sensible tilde expansion.
my(@fileopts) = qw[P d s o];
map {
	$opts{$_} =~ s/^\~(\w+)?/(($1) ? getpwnam($1):getpwuid($<))[7]/e; 
} @fileopts;

my ($prefix, $dumpfile, $rcfile, $outfile) = @opts{qw[P d s o]};
$prefix 	||= '/usr/local/slash';
$dumpfile	||= './site.dump';
$rcfile 	||= './slashdotrc.pl';
$outfile	||= './bender.dump';

die "FATAL ERROR: Can't read $rcfile: $!\n"
	if ! -r $rcfile;
die "FATAL ERROR: Can't read input dump file: $!\n"
	if ! -r $dumpfile;

$rcfile =~ s!^(.+)/!!;
my $rcdir = $1 || '.';
unshift(@INC, $rcdir);
require $rcfile;
*my_conf = $Slash::conf{DEFAULT};

my(@updateFile);
open(INFILE, "<$prefix/sql/updates/$PROGNAME")
	or die "Can't read update file $prefix/sql/updates/$PROGNAME: $!\n";
@updateFile = <INFILE>;
map { chomp } @updateFile;
close(INFILE);

# Process table status directives from update file.
my(@rtables, @otables);
for (@updateFile) {
	/^#### %REQUIRED TABLES: (.+)$/ && do {
		push (@rtables, split(/\s*,\s*/, $1));
		next;
	};

	/^#### %OBSOLETE TABLES: (.+)$/ && do {
		push (@otables, split(/\s*,\s*/, $1));
		next;
	};
}

# Sanitize array of all unnecessary entries.
@updateFile = grep { ! /^(#.+|\s+)?$/ } @updateFile;

# Create temporary database.
my $tempDBname = tempDBname();
my $dbh = DBI->connect($my_conf{dsn}, $my_conf{dbuser}, $my_conf{dbpass}, {
	PrintError => 0,
}) or
	exit 1;
$dbh->do("CREATE DATABASE $tempDBname") ||
	die "Can't create temporary database for conversion: " . 
		$dbh->errstr . "\n";
$dbh->disconnect();
$my_conf{dsn} =~ /host(?:name)?=(\w+)\b/;
my $dbhostname = $1 || 'localhost';
$dbh = DBI->connect("DBI:mysql:database=$tempDBnam;host=$dbhostname", 
		    $my_conf{dbuser}, $my_conf{dbpass}, {PrintError=>0});
die "Can't connect to temporary conversion database!\n" if !$dbh;

# Perform selective import of given dump.
importDump();

# Perform schema updates on loaded tables.
for (@updateFile) {
	$dbh->do($_) or
		printf STDERR "Error executing '$_': %s\n", $dbh->errstr;
}

# Perform version specific conversion process.
authors2Users();
aid2uid();
codes2CodeParam();
userskey2Param();

# Drop obsolete tables.
for (@otables) {
	print "-- Dropping obsolete table '$_'\n";
	$dbh->do("DROP TABLE $_");
}

# Make dump of temporary database.
print "-- Creating output dump '$outfile'\n";
system("mysqldump -u $my_conf{dbuser} -p$my_conf{dbpass} $tempDBname > $outfile");
print "DONE!\n";


END {
	# Destroy temporary database.
	if ($dbh) {
		$dbh->do("DROP DATABASE $tempDBname") ||
			printf STDERR <<EOT, $dbh->errstr;
Cannot DROP DATABASE '$tempDBname': %s
Database drop should be performed manually!

EOT
		$dbh->disconnect;
	}
};

# %%%%% SUBROUTINE DEFINITIONS %%%%%

sub tempDBname {
	my $size = shift || 6;
	my $ret = 'slashConvert';
	my @chars = ('A'..'Z', 'a'..'z', '0'..'9');

	while ($size) {
		$ret .= $chars[int(rand($#chars + 1))];
		$size--;
	}

	$ret;
}


sub importDump {
	my @vtables = (@rtables, @otables);

	print "-- Opening $dumpfile\n";
	open(DUMPFILE, "<$dumpfile") or 
		die "FATAL ERROR: Odd! Can't open dumpfile for reading: $!\n";
	while (! eof DUMPFILE) {
		my $cmd = '';
		do {
			my $c = <DUMPFILE>;
			chomp($c);
			$cmd .= $c;
		} until $cmd =~ /\;$/ || eof DUMPFILE;
		next if $cmd =~ /^(#|\s+)$/;

		# We only deal with CREATE TABLE and INSERT statements for now.
		my ($op, $tablename);
		if ($cmd =~ /(?:(CREATE) TABLE (.+?)|(INSERT) INTO (.+?) VALUES)/i) {
			($op, $tablename) = (uc $1, uc $2);
			local $" = '|';
			my $valid = ($tablename =~ /"(@vtables)"/);
			print "---- Skipping command '$cmd'\n" && next 
				if ! $valid;
		} else {
			print "---- Skipping command '$cmd'\n";
		}
		
		print "-- Creating table '$tablename'\n" if $op eq 'CREATE';
		$dbh->do($cmd);
	}
	print "-- Closing $dumpfile\n";
}


sub authors2Users {
	my $sth = $dbh->prepare('SELECT * FROM authors');
	if (! $sth->execute) {
		err("Can't execute on statement handle: ".$dbh->errstr);
		return;
	}
	my $data = $sth->fetchall_arrayref({});
	$sth->finish;

	for (@{$data}) {
		# Search users table for a matching nickname for the AID.
		my $l_sth = $dbh->prepare('SELECT * FROM users WHERE nickname=' .
			$dbh->quote($_->{aid}));
		if (! $l_sth->execute) {
			err("Can't exacute on USER statement handle: ".$dbh->errstr);
			next;
		}
		my $user = $l_sth->fetchrow_hashref;
		$l_sth->finish;
		
		my ($uid, $user_info) = (0, 0);
		my $qn = $dbh->quote(($user) ? $user->{nickname} : $_->{aid});
		if (! $user) {
			# Insert author as a new user into the database.
			print STDERR "-- Creating user account for author $qn\n";
			$dbh->do(<<EOQ);
INSERT INTO users (uid, nickname) VALUES (null, $qn)
EOQ

			# Get full user record back from database.
			#$l_sth = $dbh->prepare("SELECT * FROM users WHERE nickname=$qn");
			if (! $l_sth->execute) {
				err("Can't exacute on USER statement handle: $dbh->errstr\n");
				next;
			}
			($uid) = $l_sth->fetchrow_array;
			$l_sth->finish;

			$dbh->do(<<EOQ);
INSERT INTO users_info (uid) VALUES ($uid)
EOQ
			$dbh->do(<<EOQ);
INSERT INTO users_index (uid) VALUES ($uid)
EOQ
			$dbh->do(<<EOQ);
INSERT INTO users_comments (uid) VALUES ($uid)
EOQ
			$dbh->do(<<EOQ);
INSERT INTO users_prefs (uid) VALUES ($uid)
EOQ
		} else {
			print STDERR "-- Promoting user $qn.\n";
		}
		
		# Retrieve necessary user information to use as defaults.
		$uid = $user->{uid};
		$aidCache{$_->{aid}} = $uid;	# Used in aid2Uid().
		$l_sth = $dbh->prepare("SELECT bio FROM users_info WHERE uid=$uid");
		if ($l_sth && $l_sth->execute) {
			$user_info = $l_sth->fetchrow_hashref;
			$l_sth->finish;
		}

		# Change/Set the proper seclev.
		$user->{seclev} = $_->{seclev};

		# Add in author information for anything that isn't currently set.
		$user_info->{bio}	||= $_->{copy};
		$user->{realname}	||= $_->{name};
		$user->{realemail}	||= $_->{email};
		$user->{homepage}	||= $_->{url};
		$user->{sig} 		||= $_->{quote};

		# Update regular tables.
		$dbh->do(<<EOQ);
UPDATE users SET	
	seclev 		= $user->{seclev},
	realname 	= @{\($dbh->quote($user->{realname}))},
	realemail	= @{\($dbh->quote($user->{realemail}))},
	homepage	= @{\($dbh->quote($user->{homepage}))},
	sig			= @{\($dbh->quote($user->{sig}))}
WHERE uid = $user->{uid}
EOQ

		$dbh->do(<<EOQ);
UPDATE users_info SET bio = @{\($dbh->quote($user_info->{bio}))}
EOQ

		# There should be no defaults for these.
		$dbh->do(<<EOQ) if $_->{section};
INSERT INTO users_params (param_id, uid, name, value)
	VALUES (null, $uid, 'section', @{\($dbh->quote($_->{section}))})
EOQ

		$dbh->do(<<EOQ) if $_->{deletedsubmissions};
INSERT INTO users_params (param_id, uid, name, value)
	VALUES (null, $uid, 'deletedsubmissions', $_->{deletedsubmissions})
EOQ
	}
}


sub aid2uid {
	my @tables = qw[stories newstories];

	for (@tables) {
		my $sth = $dbh->prepare("SELECT distinct aid FROM $_");
		my @authorList;
		for (@{$sth->fetchall_arrayref}) {
			push @authorList, $_->[0];
		}

		$dbh->do("ALTER TABLE $_ ADD uid int");

		for (@authorList) {
			my $qn = $dbh->quote($_);
			$dbh->do("UPDATE $_ SET uid=$aidCache{$_} WHERE aid=$qn");
		}

		$dbh->do("ALTER TABLE $_ DROP aid");
	}
}


sub codes2CodeParam {
	my @tables = qw[commentcodes displaycodes isolatemodes issuemodes
					maillist statuscodes postmodes];

	for (@tables) {
		print STDERR "-- Processing table $_ into CODE_PARAM\n";

		my $sth = $dbh->prepare("SELECT * FROM $_");
		my $table = $dbh->quote($_);
		
		for (@{$sth->fetchall_arrayref({})}) {
			my $code = $dbh->quote($_->{code});
			my $name = $dbh->quote($_->{name});

			$dbh->do(<<EOQ);
INSERT INTO code_param (param_id, type, code, name)	
	VALUES(null, $table, $code, $name)
EOQ
		}
	}
}


sub userskey2Param {
	my $sth = $dbh->prepare("SELECT * FROM users_key");
	print STDERR "-- Processing table USERS_KEY into table USERS_PARAM\n";
	for (@{$sth->fetchall_arrayref({})}) {
		my $pubkey = $dbh->quote($_->[1]);

		$dbh->do(<<EOQ);
INSERT INTO users_param (param_id, uid, name, value)
	VALUES (null, $_->[0], 'key', $pubkey)
EOQ
	}
}


sub err {
	my $msg = shift;
	chomp $msg;
	printf STDERR "%s - %s\n", (caller(1))[3], $msg;
}


sub usage {

	print <<EOT;

usage: $PROGNAME {-Psdo?h}

	-P Prefix for Slash install 		[default: /usr/local/slash]
	-s Location of existing slashdotrc.pl	[default: ./slashdotrc.pl]
	-d Location of source MySQL dump	[default: ./site.dump]
	-o Location of output dump 		[default: ./bendersite.dump]
	-? Displays this help screen (also -h)

Notes: 
	User given in slashdotrc.pl should have global CREATE/DROP priviledges
	when this program is run. See INSTALL file for more details.	

EOT

	exit 0;
}

0;
