#!/usr/bin/perl -w
# This code is a part of Slash, and is released under the GPL.
# Copyright 1997-2001 by Open Source Development Network. See README
# and COPYING for more information, or see http://slashcode.com/.
# $Id$

use strict;
use File::Basename;
use FindBin '$Bin';
use Getopt::Std;
use DBIx::Password;
use Digest::MD5 'md5_hex';
use vars qw(%my_conf);

(my $VERSION) = ' $Revision$ ' =~ /\$Revision:\s+([^\s]+)/;
my $PROGNAME = basename($0);
(my $PREFIX = $Bin) =~ s|/[^/]+/?$||;

my %opts;
# Remember to doublecheck these match usage()!
usage('Options used incorrectly') unless getopts('Ihvu:', \%opts);
usage() if $opts{'h'};
version() if $opts{'v'};
usage('Need virtual user') unless $opts{'u'};
push @ARGV, './slashdotrc.pl' if !@ARGV;
usage("Need slashdotrc.pl file") unless my $rcfile = $ARGV[0];

####################################
# disclaimer
{
	# We don't ask this if we are in incremental-mode.
	last if $opts{I};

	my $answer = ask(<<'EOT');
SLASH v1.0 (The Beast) to Slash v2.2 (Fry) Conversion Utility
	based on original slash1toslash2 script by pudge
 	2.2 conversions by Cliff


By running this I realize that there is no warranty, expressed or implied.
Any data loss as a result of running this program is my responsibility.
I have read the documentation for this program, I understand it, and I
have taken the necessary precautions and done the required preparation.
[yes/No]
EOT
	exit unless $answer eq 'yes';
}

####################################
# setup

# Turn off warnings while processing the RC file.
$^W = 0; require $rcfile; $^W = 1;
*my_conf = $Slash::conf{DEFAULT} = $Slash::conf{DEFAULT};

my $dbh_old = DBI->connect(@my_conf{qw[dsn dbuser dbpass]});
die "Can't open connection to existing database!" unless $dbh_old;
my $dbh_new = DBIx::Password->connect($opts{'u'});
die "Can't open connection to new database!" unless $dbh_new;

END {
	$dbh_old->disconnect if $dbh_old;
	$dbh_new->disconnect if $dbh_new;
}

my @user_tables = qw(
	users users_comments users_info users_index users_prefs users_param
);

my($vars, $del_users);
my(%ac_uid, %topics, %discussions, %polls, %comments, %skip_polls);
my(%story_authors, @new_polls);

my $usersub;
my (%conversions) = (
	# This will probably not remain a straight copy for long.
	'sections'		=> undef,

	'blocks'		=> sub {
		my($data, $skip_blocks) = @_;
		return if exists $skip_blocks->{$data->{bid}};

		if ($data->{bid} eq 'colors' || $data->{bid} =~ /_colors$/) {
			my $nc = '[^,]+,?';
			my $search = "($nc$nc$nc$nc)($nc$nc$nc$nc)";
			$data->{block} =~
				s/^$search$/$1#CCCCCC,$2,#CCCCCC/;
		}

		# Handle sitename changes in blocks.
		my $searchfor = quotemeta($my_conf{rootdir});
		$data->{block} =~ s/$searchfor/$vars->{rootdir}/g
			if $data->{block};

		# Drop columns.
		delete $data->{aid};
		delete $data->{blockbak};

		return $data;
	},

	'tzcodes'		=> sub {
		my($data) = @_;
		$data->{off_set} = $data->{offset};
		delete $data->{offset};
		$data->{tz} = uc $data->{tz};
		return $data;
	},

	'content_filters'	=> sub {
		my($data) = @_;
		delete $data->{maximum_length};
		# Since this used to be "comment_filters" and then evolved into
		# "comtent_filters", we should be specific about what we
		# are filtering. The default is for 'comments' as The Beast
		# didn't have a concept of much more than that.
		$data->{form} = 'comments';
		return $data;
	},

	'topics'		=> sub {
		my($data) = @_;
		$data->{name} = $data->{tid};
		delete $data->{tid};
		return $data;
	},

	'discussions'		=> sub {
		# Convert discussion primary key into a sequence.
		my($data) = @_;
		if (! $data->{url}) {
			printf <<EOT, ($data->{sid}) ? "($data->{sid})":'';
      Discussion "$data->{title}" %s had null URL; skipping...
EOT

		 	return;
		}

		# Program should accept a default topic for discussions.
		$data->{'topic'} = -1;
		# Admins must disable stories via their own criterion.
		$data->{'type'} = 0;

		$data->{'ALLOWED_FIELDS'} = [qw(
			id sid title url topic ts type
		)];

		# NOTE: commentcount and writestatus will be converted 
		# after the stories table has been processed.
			
		return $data
	},

	'users'			=> ($usersub = sub {
		my($data) = @_;

		# This should even handle the cases of new additions to MAIN
		# code (read: Slashdot-only) -- IE users_info.rtbl. -- If 
		# the MAIN based site uses these fields, they'll get copied
		# if they don't, no problem.

		# Resolve UID collisions (anonymous user)
		$data->{uid} = $ac_uid{$data->{uid}}
			if !$opts{I} && exists $ac_uid{$data->{uid}};

		$data->{seclev} = 1
			if exists $data->{seclev} && $data->{seclev} == 0;

		$data->{tzcode} = uc($data->{tzcode})
			if exists $data->{tzcode};

		$data->{passwd} = md5_hex($data->{passwd})
			if exists $data->{passwd};

		# Valid fields for ALL user_* tables since they all use
		# the same filter. Anything not in this list will be dropped
		# from $data at INSERT time.
		$data->{ALLOWED_FIELDS} = [qw(
			uid nickname realemail fakeemail homepage passwd sig
			seclev matchname newpasswd
			points posttype defaultpoints highlightthresh
			maxcommentsize hardthresh clbig clsmall reparent nosigs
			commentlimit commentspill commentsort noscores mode
			threshold
			extid exaid exsect exboxes maxstories noboxes
			totalmods realname bio tokens lastgranted karma maillist
			totalcomments lastmm lastaccess lastmmid m2fair m2unfair
			m2unfairvotes upmods downmods session_login
			willing dfid tzcode noicons light mylinks lang
		)];

		return $data;
	}),
	
	'users_comments'	=> $usersub,
	'users_index'		=> $usersub,
	'users_info'		=> $usersub,
	'users_prefs'		=> $usersub,
	
	'stories'		=> sub {
		my($data, $hitlist, $storylist) = @_;
		$data->{uid} = $story_authors{lc($data->{aid})};
		# This is fatal.
		die <<EOT if !$data->{uid};
      NULL UID DETECTED FOR AUTHOR '$data->{aid}' IN STORY '$data->{sid}'
EOT
	
		# We need to COPY the data to the story list.
		my $datacopy;
		while (my($key, $value) = each %{$data}) { 
			$datacopy->{$key} = $value;
		}
		push @{$storylist}, $datacopy if $storylist;
		delete $data->{aid};
		$data->{tid} = $topics{$data->{tid}} || $topics{''};

		$data->{discussion} = $discussions{$data->{sid}};
		$data->{hits} = $hitlist->{$data->{sid}}{hits} || 0;
		$data->{flags} = 'data_dirty'
			if $data->{writestatus} == 1;
		$data->{flags} = 'delete_me'
			if $data->{writestatus}==5 || $data->{writestatus}==10;
		# Use to properly assign topics to story-based discussions.
		#$story_topics{$data->{sid}} = $data->{tid};
		my %newfields;
		map { $newfields{$_} = $dbh_new->quote($data->{$_}) }
			qw[sid introtext bodytext relatedtext];
		$dbh_new->do(<<EOT);
INSERT INTO story_text (sid, introtext, bodytext, relatedtext) VALUES
	($newfields{sid},
	 $newfields{introtext}, 
	 $newfields{bodytext},
	 $newfields{relatedtext})
EOT

	 	delete $data->{introtext};
		delete $data->{bodytext};
		delete $data->{relatedtext};
		# extratext just goes awaaaayyy.....
		delete $data->{extratext};
		# ...and writestatus, hitparade and commentcount join 'em!
		delete $data->{writestatus};
		delete $data->{hitparade};
		delete $data->{commentcount};

		return $data;
	},

	'pollquestions'		=> sub {
		my($data) = @_;
		$data->{'discussion'} = $discussions{$data->{qid}};
		# Program should accept a default topic for polls.
		$data->{'topic'} = -1;
		push @new_polls, $data->{qid} if $opts{I};
		delete $data->{qid};
		return $data;
	},

	'pollanswers'		=> sub {
		my($data) = @_;
		return if exists $skip_polls{$data->{qid}};
		# Note AID here does means "ANSWER ID", not "author id".
		my $oldpoll = $data->{qid};
		$data->{qid} = $polls{$oldpoll};
		if (! $data->{qid}) {
			print <<EOT;
      Skipping answers for deleted poll '$oldpoll'
EOT
			$skip_polls{$oldpoll}++;
			return;
		}
		return $data;
	},

	'pollvoters'		=> sub {
		my($data) = @_;
		# Fix UID.
		$data->{uid} = $ac_uid{$data->{uid}} 
			if exists $ac_uid{$data->{uid}};
		$data->{qid} = $polls{$data->{qid}};
		return $data;
	},

	'moderatorlog'		=> sub {
		my($data) = @_;
		my $sid = $data->{sid};
		$data->{sid} = $discussions{$data->{sid}};
		# We do not import records for comments without a discussion.
		return if !$data->{sid};
		my $oldcid = $data->{cid};
		$data->{cid} = $comments{$sid}->{$oldcid};
		(print <<EOT and return) if !$data->{cid};
      Warning: NULL CID found for '$sid' #$oldcid - record not imported.
EOT
		return $data;
	},

	'submissions'		=> sub {
		my($data) = @_;
		# Fix UID.
		$data->{uid} = $ac_uid{$data->{uid}} 
			if exists $ac_uid{$data->{uid}};

		$data->{tid} = $topics{$data->{tid} || ''};
		$data->{submitter} = $ac_uid{-1};
		$data->{ALLOWED_FIELDS} = [qw(
			subid email name time subj story tid note section
			comment uid del
		)];
		return $data;
	},

	'metamodlog'		=> sub {
		# copy straight, but fix uid when handling anonymous user (or
		# user which may be moved around as result of AC UID).
		my($data) = @_;
		$data->{uid} = $ac_uid{$data->{uid}} 
			if exists $ac_uid{$data->{uid}};
		return $data;
	},

);

# List the conditions necessary for incremental updates for all 
# updatable tables.
# 
# Users have the same condition, so we encapsulate it here.
my $usercond = {
	cond	=> 'uid  > %ld',
	field 	=> 'uid',
	type	=> 'int',
};

# Each condition is an sprintf format string.
my (%conditions) = (
	'abusers'	=> {
		cond	=> 'abuser_id > %ld',
		field	=> 'abuser_id',
		type	=> 'int',
	},
	'accesslog' 	=> {
		cond	=> 'id > %ld',
		field	=> 'id',
		type	=> 'int',
	},
	'comments'	=> {
		cond	=> 'date > %s',
		field	=> 'date',
		type	=> 'date',
	},
	'discussions'	=> {
		cond	=> 'ts > %s',
		field	=> 'ts',
		type	=> 'date',
	},
	#Ignoring hitters
	'metamodlog'	=> {
		cond	=> 'id > %ld',
		field	=> 'id',
		type	=> 'int',
	},
	'moderatorlog'	=> {
		cond	=> 'id > %ld',
		field	=> 'id',
		type	=> 'int',
	},
	'pollquestions' => {
                cond    => 'date > %s',
                field   => 'date',
                type    => 'date',
        },
        #Stories will need special treatment.
        'submissions'   => {
                cond    => 'time > %s',
                field   => 'time',
                type    => 'date',
        },
        'users'		 => $usercond,
	'users_comments' => $usercond,
	'users_index'	 => $usercond,
	'users_info'	 => $usercond,
	'users_prefs'	 => $usercond,
);
 
####################################
# main body
{
        my($sth_d, $allow_heaps);
        my @prefs = qw(mysql_heap_table absolutedir comment_minscore);
        push @prefs, 'anonymous_coward_uid' if $opts{I};
 
	# Get AC UID, heap preference.
	{
		local $" = ',';
		map { $_ = $dbh_new->quote($_) } @prefs;
		$sth_d = $dbh_new->prepare(<<EOT);
SELECT name, value FROM vars WHERE name IN (@prefs)
EOT
	}
	$sth_d->execute();
	my $err = $dbh_new->errstr;
	die "Error in retrieving variable settings: $err\n" if $err;
	while (my $ar = $sth_d->fetchrow_arrayref) {
		$ac_uid{-1} = $ar->[1]
			if $ar->[0] eq 'anonymous_coward_uid';
		$vars->{$ar->[0]} = $ar->[1];
	}

	if ($opts{I}) {
		incremental();
		refill_heaps() if $allow_heaps;
		# We're done.
		exit 0;
	}	

	####################################
	# Questions: fix AC UID, heaps.
	$ac_uid{-1} = ask(<<'EOT');
Please select a UID for the anonymous user of the site.  It is probably
best if it is the lowest positive integer that is unused on the old
Slash 1.0 site.  Enter the integer here (enter "1" to do no change):
EOT

	die "[$ac_uid{-1}] is not an integer.\n" unless $ac_uid{-1} =~ /^\d+$/;

	$del_users = ask(<<'EOT') =~ /^y/i;
Should we delete all rows from the existing users tables? If not, you should
take steps to insure that no user collisions will result as the importer
will otherwise attempt to merge the user databases, and a collision will
cause a fatal error. [yes/No]: 
EOT

	if ($ac_uid{-1} != 1) {
		for (@user_tables) {
			$dbh_new->do("DELETE FROM $_ WHERE uid=1");
		}

		$dbh_new->do(<<EOT);
UPDATE vars SET value=$ac_uid{-1} WHERE name='anonymous_coward_uid'
EOT

	}

	if ($del_users) {
		for (@user_tables) {
			$dbh_new->do("DELETE FROM $_");
		}
	}

	# We only ask about the heaps if it's set in the vars.
	$do_heaps = ask(<<'EOT') =~ /^(y(es)?)?\s*$/i if $allow_heaps;
Should we populate the heap tables during this conversion? 
(Recommended: Only answer NO to this question if you know what you are doing)
[Yes/no]
EOT

	print "Skipping HEAP table creation at your request!\n"
		if !$do_heaps && $allow_heaps;
	
	convert();

	# populate heap tables.
	refill_heaps() if $do_heaps;
}


sub incremental {
	# Reload topic data for the rest of the show.
	reload_keys('topics', \%topics, 'tid', 'alttext');

	# Discussions.
	update('discussions');
	reload_keys('discussions', \%discussions, 'sid', 'sid', 'id');

	# Stories.
	#
	# Determine list of authors, before story processing.
	get_authors();
	update_stories();

	# Polls.
	update('pollquestions');
	reload_keys('pollquestions', \%polls, 'qid', 'date');
	update_pollresults();
	%skip_polls=(); %polls=();

	# Comments - This only PARTIALLY works. Records referring to 
	# comments that are NOT imported with this run do not exist
	# since there is no clear way to link a comment from $dbh_old
	# with $dbh_new (sid+cid => unique cid). It's "good enough"
	# for testing purposes.
	#
	# If you need consistent comment records, for now a full import is
	# your only option.
	copy_comments();

	# And the rest of the rabble.
	update('moderatorlog');
	%discussions=(); %comments=();

	for my $table (@user_tables, qw(submissions metamodlog)) {
		# users_param table does not exist in BEAST's schema.
		next if $table eq 'users_param';
		update($table);
	}
	%topics=();
	users_keys();
}


# Technically, this will work on any table with a non date/int key that
# we want to update. Something to think about for the future.
sub update_stories {
	my ($del_table) = @_;
	my (@stories, %hitlist);

	$del_table ||= 0;
	map { s/^(database=)?([^;]+);?(.+)?$/$2/; }
		my($old_name, $new_name)=($dbh_old->{Name}, $dbh_new->{Name}); 

	# This is a sneaky, evil query! And MySQL's alias processor needs some
	# damned work. I shouldn't NEED to refer to $dbh_old in the query at
	# all since that's the handle I'm using!!
	my $sql = <<EOT;
SELECT ${old_name}.stories.* FROM ${old_name}.stories
	LEFT JOIN
		${new_name}.stories ON
		${old_name}.stories.sid=${new_name}.stories.sid
	WHERE ${new_name}.stories.sid IS NULL
EOT

	my $sth_s = $dbh_old->prepare($sql);
	$sth_s->execute;
	my $err = $dbh_new->errstr;
	die "SQL: $sql\n" if $err;
	# Load the hits for processing.
	load_storystuff(\%hitlist);
	do_handle('stories', $sth_s, $del_table, \%hitlist, \@stories);

	# Now go back and handle discussion updates.
	print "Reprocessing discussions and hitparade...\n";
	for (@stories) {
		my ($sid, $title, $time) = @{%{$_}}{qw(sid title time)};
		for ($sid, $title, $time) { $_ = $dbh_new->quote($_); }
		my $sql = <<EOT;
INSERT INTO discussions (sid, title, url, topic, ts, type, uid, flags)
	VALUES (
		$sid,
		$title,
		"$vars->{rootdir}/article.pl?sid=$sid",
		$topics{$_-{tid}},
		$time,
		0,
		$_->{uid},
		'hitparade_dirty'
	)
EOT

		$dbh_new->do($sql);
		my $err = $dbh_new->errstr;
		die "SQL: $sql\n" if $err;

		# And link the story to the new discussion!
		$dbh_new->do(<<EOT);
UPDATE stories SET discussion=LAST_INSERT_ID() WHERE sid=$sid
EOT

		die "Couldn't set story to refer to new discussion!\n"
			if $dbh_new->errstr;

		my $val = $comment_minscore;
		for (split /,/, $_->{hitparade}) {
			$sql =  <<EOT;
INSERT INTO discussions_hitparade (discussion, threshold, count)
	VALUES ($discussions{$sid}, @{[$val++]}, 0)
EOT

			$dbh_new->do($sql);
			$err = $dbh_new->errstr;
			die "SQL: $sql\n" if $err;
		}
	}
}


sub update_pollresults {
	return if !@new_polls;
	printf "Updating results from %d new polls...\n", scalar @new_polls;
	for (@new_polls) {
		my $sth_s = $dbh_old->prepare(<<EOT);
SELECT * FROM pollanswers WHERE qid=$_
EOT

		$sth_s->execute();
		do_handle('pollanswers', $sth_s, 0);

		$sth_s = $dbh_old->prepare(<<EOT);
SELECT * FROM pollvoters WHERE qid=$_;
EOT

		$sth_s->execute();
		do_handle('pollvoters', $sth_s, 0);
	}
}


####################################
# Full conversion subroutine.
sub convert {
	# abusers, Actually, this should be converted!!!

	# First, we determine if we need to do some creative user renumbering
	# when dealing with the AC user.
	fix_ac();

	# Sections: This probably will NOT stay a straight copy for long.
	duplicate('sections', 1);

	# offset -> off_set
	duplicate('tzcodes', 'tz');

	duplicate('content_filters', 1);

	# Replace topics dropping the character based tid for the new sequence.
	duplicate('topics', 1);
	reload_keys('topics', \%topics, 'tid', 'alttext');
	
	duplicate('discussions', 1);
	reload_keys('discussions', \%discussions, 'sid', 'sid', 'id');

	for (@user_tables) {
		# users_param does not exist in MAIN.
		next if $_ eq 'users_param';
		duplicate($_, 0);
	}

	# put keys into users_param
	users_keys();

	# update aid's etc.
	fix_authors();

	# Stories: Merge with storiestuff data, uid, aid, sid, tid
	# removal of all text fields into their own table (story_text).
	update_stories(1);
	
	duplicate('pollquestions', 1);
	reload_keys('pollquestions', \%polls, 'qid', 'date');

	duplicate('pollanswers', 1);
	# Done with %skipped_polls.
	%skip_polls = ();

	duplicate('pollvoters', 1);
	# Done with polls by this point.
	%polls = ();

	copy_comments();

	# Moderatorlog: Fix sid, cid.
	duplicate('moderatorlog', 1);
	# Desperately needed, if you have a site the size of Slashdot, you're 
	# probably running out of memory right about now.
	%discussions = ();
	%comments = ();

	# Submissions: Fix uid, tid
	duplicate('submissions', 1);

	# do all the blocks stuff
	copy_blocks();
	fix_sectionblocks();

	fix_vars();

	# Ignoring: formkeys, accesslog 
	# Metamodlog: This should go fine as a direct copy fixing the AC uid.
	duplicate('metamodlog', 1);
}


####################################
sub ask {
	local $| = 1;

	chomp(my $question = $_[0]);
	print "\n", $question, " ";

	chomp(my $answer = <STDIN>);
	print "\n";
	return $answer;
}

sub fix_ac {
	print "Checking user database...\n";

	# First, check to see if the desired UID is occupied...
	my $sth_s = $dbh_old->prepare(<<EOT);
SELECT uid FROM users WHERE uid=$ac_uid{-1}
EOT

	$sth_s->execute;
	my ($uid) = $sth_s->fetchrow_array;
	$sth_s->finish;

	# If so, we must find the first free UID.
	if ($uid) {
		# Now do a user count.
		$sth_s = $dbh_old->prepare("SELECT max(uid) FROM users");
		$sth_s->execute;
		my($maxuid) = $sth_s->fetchrow_array;
		$sth_s->finish;
		# Find the first gap.
		$sth_s = $dbh_old->prepare(<<EOT);
SELECT uid FROM users WHERE uid >= 1 ORDER BY uid
EOT

		$sth_s->execute;
		my $lastuid;
		while (my $c = $sth_s->fetchrow_arrayref) {
			if (! $lastuid) {
				$lastuid = $c->[0];
				next;
			}
			last if $c->[0] != $lastuid + 1;
			$lastuid = $c->[0];
		}
		$lastuid++;
		printf <<EOT;
Existing user found at UID #$ac_uid{-1} will be moved to UID #$lastuid
EOT

		$ac_uid{$ac_uid{-1}} = $lastuid;
	}
}

####################################
sub refill_heaps {
	printf "%sPopulating the story_heap table...\n", ($opts{I}) ? 'Re':'';
	$dbh_new->do('DELETE FROM story_heap') if ($opts{I});
	$dbh_new->do('INSERT INTO story_heap SELECT * FROM stories');
	printf "%sPopulating the comment_heap table...\n", ($opts{I}) ? 'Re':'';
	$dbh_new->do('DELETE FROM comment_heap') if ($opts{I});
	$dbh_new->do('INSERT INTO comment_heap SELECT * FROM comments');
}

####################################
# get vars out of slashdotrc.pl
sub fix_vars {
    print "Processing vars\n";

    # Some of these 'm2_*' vars should be removed.
    for (qw(mailfrom siteadmin siteadmin_name smtp_server
    	sitename slogan mainfontface updatemin
    	archive_delay submiss_ts articles_only
    	allow_anonymous use_dept max_depth
    	defaultsection http_proxy fancyboxwidth
    	story_expire titlebar_width run_ads
    	authors_unlimited m2_comments m2_maxunfair
    	m2_toomanyunfair m2_bonus m2_penalty
    	m2_userpercentage comment_minscore
    	comment_maxscore submission_bonus goodkarma
        badkarma maxkarma metamod_sum maxtokens
    	tokensperpoint maxpoints stir tokenspercomment
    	down_moderations post_limit max_posts_allowed
    	max_submissions_allowed submission_speed_limit
    	formkey_timeframe m2_mincheck m2_maxbonus
    )) {
    	my $value = $dbh_new->quote($my_conf{$_});
    	$dbh_new->do("UPDATE vars SET value=$value WHERE name='$_'");
    }

    # don't overwrite new vars descriptions with old ones
    my $vars = $dbh_old->selectall_arrayref("SELECT name,value FROM vars");
    for my $var (@$vars) {
    	my @data = map { $dbh_new->quote($_) } @$var;
    	$dbh_new->do("UPDATE vars SET value=$data[1] WHERE name=$data[0]");
    }
}

####################################
# copy blocks, skipping certain blocks and excluding some fields,
# fixing some data
sub copy_blocks {
	my %skip_blocks = map { ($_, 1) } qw(
    		admin_footer admin_header comment commentswarning
   		edit_filter emailsponsor fancybox footer header
   		index index2 light_comment light_fancybox
    		light_footer light_header light_index light_story
    		light_story_link light_story_trailer light_titlebar
    		list_filters_footer list_filters_header mainmenu
    		menu motd newusermsg organisation pollitem
    		portalmap postvote story story_link story_trailer
    		storymore submit_after submit_before titlebar
    		userlogin
    	);

	duplicate('blocks', 'bid', \%skip_blocks);
	$dbh_new->do('INSERT INTO backup_blocks SELECT bid, block FROM blocks');
}

####################################
# add old sectionblocks data to blocks table
sub fix_sectionblocks {
	print "Processing sectionblocks\n";

	my $sth_s = $dbh_old->prepare("SELECT * FROM sectionblocks");
	$sth_s->execute;
	
	while (my $data = $sth_s->fetchrow_hashref) {
		my $bid = $dbh_new->quote($data->{bid});
		delete $data->{bid};

		my $insert = sprintf("UPDATE blocks SET %s WHERE bid=$bid",
			join ', ',
			map { "$_=" . $dbh_new->quote($data->{$_}) }
			keys %$data);

		$dbh_new->do($insert);
		my $err = $dbh_new->errstr;
		die $err if $err;
	}
}

####################################
# get users keys into users_param table
sub users_keys {
	my($max_uid, $cond) = (0, '');

	if ($opts{I}) {
		my $sth_d = $dbh_new->prepare(<<EOT);
SELECT max(uid) FROM users_param WHERE name='pubkey'
EOT
		$sth_d->execute();
		($max_uid) = $sth_d->fetchrow_array;
		$cond = "WHERE uid > $max_uid";
		print "Processing users_keys from #$max_uid...\n";
	} else {
		print "Processing users_keys...\n";
	}

	my $users = $dbh_old->selectall_arrayref(<<EOT);
SELECT uid,pubkey FROM users_key $cond
EOT

	for my $user (@$users) {
		next if !$user->[1];
		my $string = $dbh_new->quote($user->[1]);
		my $sql = <<EOT;
INSERT INTO users_param (uid,name,value) 
	VALUES ($user->[0], 'pubkey', $string)
EOT

		$dbh_new->do($sql);
		print "SQL: $sql\n" if $dbh_new->errstr;

	}
}

####################################
# bunch of things to get users fixed up
sub fix_authors {
	my $authors = $dbh_old->selectall_arrayref(<<'EOT');
SELECT aid,seclev,lasttitle,section,deletedsubmissions
FROM   authors
WHERE  name != 'All Authors'
EOT

	my(@not_found);
	
	for my $author (@$authors) {
		(my $matchname = lc $author->[0]) =~ s/[^a-zA-Z0-9]//g;
		# Take the FIRST OCCURANCE, only.
		next if $story_authors{$matchname};

		# Note that we order by UID since there CAN be MORE than one.
		my $uid = $dbh_old->selectrow_array(<<EOT);
SELECT   uid
FROM     users
WHERE    matchname='$matchname'
ORDER BY uid
EOT
		if ($uid) {
			$story_authors{$matchname} = $uid;
			my @data = map { $dbh_new->quote($_) } @$author;
			$dbh_new->do(<<EOT);
UPDATE users SET seclev=$data[1] WHERE uid=$uid
EOT

			$dbh_new->do(<<EOT);
INSERT INTO users_param (uid,name,value) VALUES ($uid, 'author', '1')
EOT

			$dbh_new->do(<<EOT) if $data[2] && $data[2] ne "NULL";
INSERT INTO users_param (uid,name,value) VALUES ($uid, 'lasttitle', $data[2])
EOT
				
			$dbh_new->do(<<EOT) if $data[3] && $data[3] ne "NULL";
INSERT INTO users_param (uid,name,value) VALUES ($uid, 'section', $data[3])
EOT
				
			$dbh_new->do(<<EOT) if $data[4]; 
INSERT INTO users_param (uid,name,value)
	VALUES($uid, 'deletedsubmissions', $data[4])
EOT
				
		} else {
			push @not_found, $matchname;
		}
	}

	# Grab orphaned authors that might be in stories and nowhere else.
	{
		my $sa = $dbh_old->selectall_arrayref(<<EOT);
SELECT DISTINCT aid FROM stories
EOT

		for (@{$sa}) {
			my $s_auth = lc($_->[0]);
			local $" = '|';
			my $regexp =
				"^(@{[keys %story_authors, @not_found]})\$";
			push @not_found, $s_auth if $s_auth !~ /$regexp/;
		}
	}


	my %other_authors;
	print "\n== RESOLVING MISSING AUTHORS ==\n";
	for my $nf (@not_found) {
		print <<EOT;

== No corresponding user found for Author '$nf'

Please select UID:
EOT
		print "\n\tCurrent Authors\n\t---------------\n";
		for (keys %story_authors) {
			printf "\t%-30s: #$story_authors{$_}\n", $_;
		}
		if (keys %other_authors) {
			print <<EOT;

	Current Author Assigns
	----------------------
EOT
			for (keys %other_authors) {
				printf "\t%-30s-> #$other_authors{$_}\n", $_;
			}
		}

		my $uid;
		while (!$uid || $uid !~ /^\d+$/) {
			$uid = ask("UID for AUTHOR '$nf': ");
			chomp($uid);
		}
		$other_authors{$nf} = $uid;
	}
	map { $story_authors{lc($_)} = $other_authors{$_} }
		keys %other_authors;
}


sub load_storystuff {
	my ($hitlist) = @_;

	print "Loading hitcounts into story metadata...\n";
	my $sth_s = $dbh_old->prepare('SELECT sid, hits FROM storiestuff');
	$sth_s->execute;
	while (my $data = $sth_s->fetchrow_hashref) {
		$hitlist->{$data->{sid}}{hits} = $data->{hits};
	}
	$sth_s->finish;
}


sub copy_comments {
	my %dead_discussions;
	my($lastdate, $cond) = ('', '');

	if ($opts{I}) {
		my $sth_d = $dbh_new->prepare(<<EOT);
SELECT max(date) FROM comments
EOT

		$sth_d->execute;
		($lastdate) = $sth_d->fetchrow_array;
		$cond = "WHERE date > " . $dbh_old->quote($lastdate);
		print "Copying comment data and texts from $lastdate...\n";
	} else {
		print "Copying comment data and texts...\n";
	}
	my $sth_s = $dbh_old->prepare("SELECT * FROM comments $cond");
	$sth_s->execute;
	while (my $data = $sth_s->fetchrow_hashref) {
		next if exists $dead_discussions{$data->{sid}};
		# Fix UID.
		$data->{uid} = $ac_uid{$data->{uid}} 
			if exists $ac_uid{$data->{uid}};
		# Fix SID.
		my $sid = $dbh_new->quote($discussions{$data->{sid}});
		if (!$discussions{$data->{sid}}) {
			$dead_discussions{$data->{sid}}++;
			print <<EOT;
      Skipping deleted discussion '$data->{sid}'
EOT

			next;
		}
		my $insert_q = sprintf
			qq[
INSERT INTO comments
(sid, pid, date, subject, uid, points, lastmod, reason)
VALUES ($sid, %s)
			],
			scalar join(', ', 
				map { $dbh_new->quote($data->{$_}) }
				qw [pid date subject uid points lastmod reason]
			);
		$dbh_new->do($insert_q);
		print "SQL: $insert_q\n" if $dbh_new->errstr;
		my $sth_d = $dbh_new->prepare('SELECT LAST_INSERT_ID()');
		$sth_d->execute;
		$comments{$data->{sid}}->{$data->{cid}} = 
			($sth_d->fetchrow_array)[0];
		$data->{comment} = $dbh_new->quote($data->{comment});
		my $sql = <<EOT;
INSERT INTO comment_text (cid, comment)
VALUES ($comments{$data->{sid}}->{$data->{cid}}, $data->{comment})
EOT

		$dbh_new->do($sql);
	}
	$sth_s->finish;

	# Now update PIDs.
	print "Updating comment heirarchy.\n";
	$sth_s = $dbh_old->prepare(<<EOT);
SELECT DISTINCT sid,pid FROM comments $cond
EOT

	$sth_s->execute;
	while (my $data = $sth_s->fetchrow_hashref) {
		next if !$data->{pid} || exists $dead_discussions{$data->{sid}};
		my $pid = $comments{$data->{sid}}->{$data->{pid}} || 0;

			my $SQL = <<EOT;
UPDATE comments SET
	pid=$pid
WHERE 	sid=$discussions{$data->{sid}} AND
	pid=$data->{pid}
EOT

		$dbh_new->do($SQL);
		print STDERR <<EOT if $dbh_new->errstr;
($data->{sid}|$data->{pid}) SQL: $SQL
EOT

	}
}


sub reload_keys {
	my($table, $key_tbl, $f1, $f2, $f3) = @_;
	$f3 ||= $f1;
	my(%old, %new);
	my $sth_s = $dbh_old->prepare("SELECT $f1, $f2 FROM $table");
	$sth_s->execute;
	while (my $data = $sth_s->fetchrow_hashref) {
		$old{$data->{$f1}} = $data->{$f2};
	};
	$sth_s->finish;
	my $sth_d = $dbh_new->prepare("SELECT $f3, $f2 FROM $table");
	$sth_d->execute;
	while (my $data = $sth_d->fetchrow_hashref) {
		$new{$data->{$f2}} = $data->{$f3};
	}
	$sth_d->finish;
	for (keys %old) {
		$key_tbl->{$_} = $new{$old{$_}};
	}
}


# The difference here is that we are retrieving this list from the IMPORTED
# database, not the original.
sub get_authors {
	my $sql = <<EOT;
SELECT users.uid, nickname FROM users, users_param
WHERE name='author' AND value=1 AND users.uid=users_param.uid
EOT

	my $sth_d = $dbh_new->prepare($sql);
	$sth_d->execute;
	my $err = $dbh_new->errstr;
	die "SQL: $sql\n" if $err;

	while (my($uid, $auth) = $sth_d->fetchrow_array) {
		$story_authors{lc($auth)} = $uid;
	}
}


sub update {
	my($table) = @_;
	my($where, $cond);

	return if !$table;
	if (!exists $conditions{$table}) {
		print "X == SKIPPING update on '$table': no conditions\n";
		return;
	}

	my $sql = <<EOT;
SELECT max($conditions{$table}->{field}) FROM $table
EOT

	my $sth_d = $dbh_new->prepare($sql);
	$sth_d->execute();
	my $err = $dbh_new->errstr;
	die "SQL ($table): $sql\n" if $err;

	my($max_id)= $sth_d->fetchrow_array();

	$cond = sprintf $conditions{$table}->{cond}, $max_id
		if $conditions{$table}->{type} eq 'int';

	$cond = sprintf $conditions{$table}->{cond}, $dbh_old->quote($max_id)
		if $conditions{$table}->{type} eq 'date';

	my $sth_s = $dbh_old->prepare(<<EOT);
SELECT * FROM $table WHERE $cond
EOT

	$sth_s->execute();
	print "Updating $table...\n" if $sth_s->rows;
	do_handle($table, $sth_s, 0);
}


####################################
# the main function to copy data from old DB to new DB
# if $opt is 1, delete table contents before inserting
# if $opt is 0, do nothing with table before inserting
# if $opt is a string, delete that specific column before inserting
sub duplicate {
	my($table, $opt, @extra) = @_;
	my $filter = $conversions{$table};

	print "Processing $table\n";

	my $sth_s = $dbh_old->prepare("SELECT * FROM $table");
	$sth_s->execute;

	do_handle($table, $sth_s, $opt, @extra);
}

sub do_handle {
	my ($table, $sth, $opt, @extra) = @_;

	die "No conversion filter for table '$table'!" 
		unless exists $conversions{$table};

	if ($opt eq 1) {
		$dbh_new->do("DELETE FROM $table");
	}

	my $filter = $conversions{$table};
	while (my $data = $sth->fetchrow_hashref) {
		$data = $filter->($data, @extra) if ref $filter eq 'CODE';
		next unless $data;

		# Remove any potential extraneous fields if specified.
		if (exists $data->{ALLOWED_FIELDS}) {
			my @fieldlist;
			push @fieldlist, @{$data->{ALLOWED_FIELDS}};
			delete $data->{ALLOWED_FIELDS};
			my $fl = join ('|', @fieldlist);
			map { delete $data->{$_} }
				grep { ! /^($fl)$/ } keys %{$data};
		}
		
		map {
			$data->{$_} = (/^-/) ? $_:$dbh_new->quote($data->{$_});
		} keys %$data;
		my $insert = sprintf("INSERT INTO $table (%s) VALUES (%s)",
			join(', ', map { s/^\-//; $_ } keys %$data),
			join(', ', values %$data)
		);

		if ($opt =~ /[a-zA-Z]/) {
			$dbh_new->do(<<EOT);
DELETE FROM $table WHERE $opt = $data->{$opt}
EOT

		}

		$dbh_new->do($insert);
		my $err = $dbh_new->errstr;
		die "$table: $err" if $err;
	}
}

sub usage {
	print "*** $_[0]\n" if $_[0];
	# Remember to doublecheck these match getopts()!
	print <<EOT;

Usage: $PROGNAME [OPTIONS] RCFILE

Converts Slash 1.0 data to Slash 1.1/2.2 data.  Type
"perldoc $PROGNAME" or "perldoc `which $PROGNAME`
for instructions on use.

Main options:
		slashdotrc.pl file from 1.0 installation
	-h	Help (this message)
	-v	Version
	-u	Virtual user (default is "slash") [REQUIRED]
	-I	Perform INCREMENTAL conversion

EOT
	exit;
}

sub version {
	print <<EOT;

$PROGNAME $VERSION

This code is a part of Slash, and is released under the GPL.
Copyright 1997-2001 by Open Source Development Network. See README
and COPYING for more information, or see http://slashcode.com/.

EOT
	exit;
}

1;

__END__


=head1 NAME

slash1toslash2 - Convert Slash 1.0 database to Slash 2.2

=head1 SYNOPSIS

	install-slashsite -u slash
	slash1toslash2 -u slash slashdotrc.pl

=head1 DESCRIPTION

Please read these instructions before starting a new Slash 2.2
site.  They are designed to convert a site from scratch; they
will not work with a Slash 2.2 site that's been used.

This program will copy data from your old Slash 1.0 database
to your new Slash 2.2 database, making direct connections to
both databases and copying the data directly between them.

It will copy over your data, but if you've done any customizations to
display blocks, or code, it will not copy that over.

A detailed description of the work done is below, L<"DETAILS">.
You might want to read this section before running the program.

Note that this is designed for converting a Slash 1.0.9 database;
any schema changes you've made, or incompatible changes from
earlier versions of Slash, may break this program.

Please follow these instructions precisely to convert your Slash 1.0
site to Slash 2.2.


=head2 Requirements

=over 4

=item *

You will need a new database to copy the new data to.  This could be
on the same database server as the Slash 1.0 data, but because
the installed modules (specifically, Slash.pm) are not compatible
between the sites, you will most likely want to have the installed
code for 1.0 and 2.2 on separate boxes.

=item *

You will need Slash 2.2 installed on some box.

=item *

You will need access to both the 1.0 and 2.2 databases from the same
box.  The program will be run from the box that has Slash 2.2 installed,
so if that box does not have access to the Slash 1.0 database, you will
need to either temporarily edit the mysql.user table of the 1.0 server
to grant access, or copy the database from the 1.0 server to the 2.2
server.

=back


=head2 BACK UP YOUR DATA

If you lose your data, it is your problem, not ours.  I deleted all of
the data on http://use.perl.org/ while preparing this program.  However,
I had a backup ready to go (although I still lost about 12 hours of
data, and I feel like an idiot).  Back up your data on your Slash 1.0
database.  You have been warned.

Also, consider what happens if you have two Slash sites on one machine;
what if you give this program the wrong virtual user?  Perhaps you
just deleted a working site!  Back up any existing data on the target
database server, too.  See, even after writing this warning, I did this,
too, and typed "slash" as my virtual user instead of "useperl", and
I overwrote some of the existing database, and didn't have a backup
for some of it.  After that, I felt like a total moron.

This program does not write to your Slash 1.0 database, so you should
be fine, but there are no warranties, expressed or implied.  If you
are running a Slash site, you should be backing up your database
nightly anyway, right?

So backup all your data on both boxes, so you don't feel like a moron,
like me.


=head2 Database Preparation

You probably won't need to change any data.  But there are three things
to check before starting.

=over 4

=item *

Make sure that there are no author/user nickname conflicts.  In
Slash 1.0, users (nicknames) and authors (AID) were separate,
so you could have a user named timothy and an author named timothy,
who were not the same person.  This is not allowed in Slash 2.2,
as those tables have been combined.

Also, every author must have a matching user, or this will fail.
If you still have a story owned by "God", for example, you need
a user with nickname "God" and matchname "god".

Most sites won't have this problem, but if yours does, it is sufficient
to change the nickname/matchname fields of any conflicting user, and
then have the author create a new account with that name.  Of course,
make sure the other user knows you are making the change, and try
to compensate him in some way, perhaps by giving him extra karma.

If you decide you would rather change the author's name, then
you will need to go through the database, in every field named
"aid" (except for the poll tables, where "aid" is "answer id",
not "author id") and change the name of that author.

Changing the name of the user is easier.

=item *

Select a user ID (UID) to be your "anonymous coward" (AC).  This
should probably be the lowest positive integer not in use on the
Slash 1.0 site.  It could be one of the six default users, or
a test user you created.

Be careful to pick a user that does not have any comments or anything
else in the system.  If there is no UID not in use, create a new test
user (as you would create any user, through users.pl) and use that UID.

=item *

Decide whether or not you want to keep the new admin account created
in your Slash 2.2 database.  Chances are, you won't want to or need
to.

However, if you do want to keep it, then you need to delete/modify all
references to that user's uid in your Slash 1.0 database.  It is easier
if you just allow this program to delete that uid from your Slash 2.2
database, though, so there is no conflict.

=back


=head2 Install Slash 2.2 Slash Site

Run the C<install-slashsite> program as described in that program's
documentation.  Remember which I<virtual user> you used to install
the site.  Do not make any changes to the database.


=head2 Copy Slash 1.0 RC File

Get the F<slashdotrc.pl> file from your Slash 1.0 site and copy it
to some directory on your Slash 2.2 box.  At this point, make sure
you can access the Slash 1.0 database from the Slash 2.2 box.

You may need to modify the slashdotrc.pl file's dbhost, dbuser,
and dbpass variables to make sure the database can be accessed
properly.  Also, make sure "$Slash::conf{DEFAULT}" is I<not>
commented out in slashdotrc.pl.


=head2 Run It

Run the program, using the proper value for virtual_user and
the proper path to the slashdotrc.pl file:

	slash1toslash2 -u virtual_user slashdotrc.pl

You will be asked three questions: do you agree to the disclaimer,
what UID do you want for AC (default is 1), and do you want to
delete the new admin user created by C<install-slashsite>
(probably yes).


=head2 Add Final Touches

Copy over any images or static files you have, and adjust the
site's templates, blocks, and variables as needed.


=head1 DETAILS

This is just a detailed run-down of what the program does, in the
order it does it.

=over 4

=item *

If you chose an AC UID of other than 1, then the new UID is
deleted from each of the users* tables, and the old AC UID (1)
is changed to the new UID in each of those tables.  Also,
the variable "anonymous_coward_uid" in the vars table is updated
to the new UID.

=item *

If you chose to delete the new admin user account created by
C<install-slashsite>, it is deleted from each of the users*
tables.  If you choose not to, then UID 2 will not be copied
from the 1.0 database; however, all stories, comments, etc.
assigned to UID 2 I<will> still be copied.

We do not bother deleting comments and stories, because
those will be overwritten later.

=item *

For the following tables, the contents are copied directly from
the 1.0 database to the 2.2 database:

	abusers content_filters discussions pollanswers
	pollquestions sections storiestuff topics

=item *

The tzcodes table is copied over directly, after converting the
column name "offset" to "off_set", and upper-casing the "tz" column
data.

=item *

For the following tables, the data is copied directly, excluding
UID -1 (old AC) and whatever the new AC UID is, and changing
seclev to be 1 (where it was 0), changing tzcode to be upper case,
and encrypting the passwd:

	users users_comments users_index users_info users_prefs

=item *

Data is taken from the old users_key field and copied into the
new users_param field.

=item *

For the following tables, the data is copied directly, after
changing UID -1 to be whatever the new AC UID is.

	comments submissions accesslog formkeys metamodlog
	moderatorlog pollvoters

=item *

As mentioned above, the authors table no longer exists, having been
rolled into the new users table.

Authors are selected from the old database, and matched to UIDs
from the new database.  Then for each UID, the seclev is changed
to the proper value, and the lasttitle, section, and
deletedsubmissions columns are taken from the old authors table
and added to the new users_param table.  Also, a flag of
"author" with value of "1" is added to the users_param table
for that UID.

A hash of author -> uid is created and saved for use in the next
step.

=item *

For the following tables, the column "aid" is replaced by the
column "uid", and the value is changed from the old author's
AID to their UID:

	stories sessions

=item *

If there are any stories that have a NULL UID, the program
asks for a UID to assign to the orphaned stories, printing
a list of available authors.

=item *

The story_heap table is populated using the data
from the stories table.

=item *

The blocks table is copied over, excluding the blocks that
were converted to templates (like header, footer, etc.).
Note that any blocks that are now templates, that were
customized in the 1.0 site, need to be re-customized in
the 2.2 site.

The "aid" and "blockbak" columns are skipped.

The skipped blocks, that are now templates, are:

	admin_footer admin_header comment commentswarning
	edit_filter emailsponsor fancybox footer header
	index index2 light_comment light_fancybox
	light_footer light_header light_index light_story
	light_story_link light_story_trailer light_titlebar
	list_filters_footer list_filters_header mainmenu
	menu motd newusermsg organisation pollitem
	portalmap postvote story story_link story_trailer
	storymore submit_after submit_before titlebar
	
Also, the "userlogin" block is skipped.  It is still in
the Slash 2.2 database as a block _and_ a template, and
as such the block is not copied from 1.0 to 2.2, since
it has changed substantially.  See the code for details.

The colors blocks are fixed; there were previously
eight colors per block, now there are ten.  The
additional colors ($fg[4] and $bg[4]) are both "#CCCCCC".
This is done for the "colors" block and any block
ending in "_colors".

The backup_blocks table is populated from the blocks table.

=item *

The data from the Slash 1.0 sectionblocks table, which
does not exist in Slash 2.2, is copied to the blocks
table.

=item *

Selected variables from slashdotrc.pl are copied to the
vars table of the Slash 2.2 database.  These are:

	mailfrom siteadmin siteadmin_name smtp_server
	sitename slogan mainfontface updatemin
	archive_delay submiss_ts articles_only
	allow_anonymous use_dept max_depth
	defaultsection http_proxy fancyboxwidth
	story_expire titlebar_width run_ads
	authors_unlimited m2_comments m2_maxunfair
	m2_toomanyunfair m2_bonus m2_penalty
	m2_userpercentage comment_minscore
	comment_maxscore submission_bonus goodkarma
	badkarma maxkarma metamod_sum maxtokens
	tokensperpoint maxpoints stir tokenspercomment
	down_moderations post_limit max_posts_allowed
	max_submissions_allowed submission_speed_limit
	formkey_timeframe m2_mincheck m2_maxbonus

Any values you don't want copied, or want to be additionally
copied, can be taken care of either by hand, or by editing
the source of this program.

=item *

The existing values from the 1.0 database vars table are copied
to the 2.2 database.

=back

=head1 INCREMENTAL UPDATES

If you invoke this program using the -I switch, an incremental conversion will
be performed. The name implies exactly what it means, each table has a condition
that will allow for incremental updates to be performed between a Beast site and
a Fry site, which is useful for sites attempting to upgrade to Fry by using another system in tandem.

An incremental update assumes that a previous conversion (or a working Slash site
already exists at the database referred to by the specified virtual user.

The following tables will remain UNTOUCHED in an incremental update:
	blocks
	code_param
	commentmodes
	content_filters
	dateformats
	menus
	sections
	templates
	topics
	tzcodes

The above tables are generally part of a theme, and this should allow for a site\
admin to CHANGE the given theme without needing to reimport the entire dataset, 
if they so desire.

=head1 VERSION

$Id$
