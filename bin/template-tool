#!/usr/bin/perl -w 
# This code is a part of Slash, and is released under the GPL.
# Copyright 1997-2001 by Open Source Development Network. See README
# and COPYING for more information, or see http://slashcode.com/.
# $Id$

# First version by Brian, brian@tanegnt.org
# Updated by Patrick Galbraith, capttofu@slashdot.org

# I hope someone takes this over. A TK frontend
# would be nice. This was Cliff's idea and kudos
# should go to him. -Brian
#
# Cliff++; -CaptTofu
use strict;
use Slash;
use Slash::Utility;
use Slash::DB;
use Slash::Install;
use Getopt::Std;
use Cwd;

my $VERSION = '0.9';
my $COPYRIGHT = 
'This code is a part of Slash, which is Copyright 1997-2001 OSDN, and
 released under the GPL.  See README and COPYING for more information.';


my %opts;
usage('no options supplied to program') unless getopts('cdilrsvD:O:P:S:p:f:u:?', \%opts);
usage('help requested') if $opts{'?'};

# if deleting, then there should be no other operation or file flags
usage('deletion with other op flags') if ( $opts{'r'} && ($opts{'d'} || $opts{'l'} || $opts{'f'} || $opts{'s'} || $opts{'e'} )); 

# can't have multiple IDs on a save
usage('too many ids to save') if (@ARGV > 2 && $opts{'s'} && $opts{'i'});

$opts{'u'} = 'slash' unless $opts{'u'};  
my $slash = Slash::DB->new($opts{'u'});
my $install = Slash::Install->new($opts{'u'});

createCurrentDB($slash);

# datastruct of ALL templates, keyed by uid
my $templates = $slash->getTemplates();


my ($sectionpage_flag, $section_flag, $page_flag, $all_flag) = (0,0,0,0);

##################################
# version
if ($opts{'v'}) {
	print "$0, Version $VERSION, $COPYRIGHT\n";
	exit();
}

##################################
# compile to perl code
if ($opts{'c'}) {
	# There is logic in making -i work with -P and -S, but I'm too tired to
	# implement that right now.
	die "Can't use -P or -S options with -i and -c!\n" 
		if $opts{i} && ($opts{P} || $opts{S});
	# (-i) Sanity check. We only want an @ARGV full of numeric arguments.
	map {
		die "Non-numeric options given with -i!\n" if /^\d+$/;
	} @ARGV if $opts{i};
	compile_template();
	exit();
}

if ($opts{'D'}) {
	if ( ! -d $opts{'D'}) {
		if ($opts{'d'} || $opts{'e'} || ( $opts{'l'} && $opts{'f'})) {
			system("mkdir $opts{'D'}") 
		} else {
			print "Invalid directory $opts{'D'} \n";
			exit(0);
		}
	}
} 

if ($opts{'S'} and $opts{'P'}) {
	$sectionpage_flag = 1;
} elsif ($opts{'S'}) {
	$section_flag = 1;
} elsif ($opts{'P'}) {
	$page_flag = 1;
} else {
	$all_flag = 1;
}

# start the processing
if ($opts{'s'}) {
	for(@ARGV) {
		my $template = $install->readTemplateFile($_);
		next unless $template;
		print "$template->{name}\n";
		my $tpid = $slash->getTemplateByName($template->{name}, 'tpid', 1, $template->{page}, $template->{section});
		if(defined($tpid)) {
			$slash->setTemplate($tpid, $template);
		} else {
			$slash->createTemplate($template);
		}
	}
} else {
	my $templatelist = {};
	my ($sectionpage_match,$no_sectionpage,$template_counter) = (0,0,0);
	my $filename;

	if ($opts{'f'}) {
		$filename = $opts{'f'};
		$filename .= $opts{'D'} . '/' . $filename if $opts{'D'};
	} 
	elsif($opts{'D'}) {
		$filename = $opts{'D'};
	}

	# build a template list of the templates we want to process
	for my $key (keys %$templates) {
		if ($opts{'p'}) {
			next unless $key =~ /$opts{'p'}/;
		}

		if ( 	($sectionpage_flag && 
			$opts{'S'} eq $templates->{$key}{section} && 
			$opts{'P'} eq $templates->{$key}{page}) 
			|| 
			($section_flag && $templates->{$key}{section} eq $opts{'S'}) 
			|| 
			($page_flag and $templates->{$key}{page} eq $opts{'P'}) ) 
		{
			$sectionpage_match = 1;
			# print "section_flag $section_flag template section $templates->{$key}{section}  opts section $opts{'S'}\n";

		} elsif ($all_flag) {
			$no_sectionpage = 1;
		} 

		if($sectionpage_match || $no_sectionpage) {
			if (@ARGV) {
				for (@ARGV) {
					if($opts{'i'}) {
						$templatelist->{$key} = $templates->{$key} if $key == $_;

					} else {
						my $templatename = $_;
						if ($templates->{$key}{name} eq $templatename) {
							$templatelist->{$key} = $templates->{$key};
							$template_counter++;
						}
					}
				}
			} 
			elsif (! $opts{'i'}) {
				$templatelist->{$key} = $templates->{$key};
				$template_counter++;
			}
			($sectionpage_match,$no_sectionpage) = (0,0);
		}
	}

	if ($opts{'l'}) {
		list_templates($templatelist, $filename);
	} 
	elsif ($opts{'d'}) {
		if ($template_counter > 1 && $opts{'f'}) {
			usage('too many templates per file');
		} else {
			dump_templates($templatelist,$filename);
		}
	}
	elsif ($opts{'r'}) {
		delete_templates($templatelist);
	}
}

###############################################
#sub save_template {
#	my ($tpid, $section, $page, $name, $file) = @_;
#	my @files;
#	my $dirflag = 0;
#	$dirflag = 1 if -d $file;
#	
#	if ($name eq '' && ! $tpid  && $dirflag) {
#		opendir(DIR, $file);
#		while(my $tmpfile = readdir(DIR)) {
#			next if $tmpfile =~ /\./;
#			print "processing $tmpfile\n";
#			push(@files, $file . '/' . $tmpfile);
#		}
#	} 
#	# this should be only one file
#	elsif (-f $file) {
#		push @files, $file;
#
#	} 
#
#	for my $tmpfile (@files) {
#		my ($tsection,$tpage,$tname,$data);
#		my ($psection,$ppage,$pname);
#		my $filename_flag = 0;
#		my $tmp = {};
#		my $exists = 0;
#
#		# you can't save a template without a section and page or without a name
#		# the file has the section, page, and name in it's filename and we don't 
#		# have a template id, so get any unset attributes from the file name
#		if($tpid) {
#			$tname = $name if $name ne '';	
#			$tpage = $page if $page ne '';
#			$tsection = $section if $section ne '';
#		}
#		elsif ($tmpfile =~ /(\w+)\;(\w+)\;(.*)$/i) {
#			$filename_flag = 1;
#			($pname,$ppage,$psection) = ($1,$2,$3);
#			$tname = $name eq '' ? $1 : $name ;
#			$tpage = $page eq '' ? $2 : $page ;
#			$tsection = $section eq '' ? $3 : $section ;
#		}
#		elsif ($name ne '') {
#			$tname = $name;
#			$tsection = $section ne '' ? $section : 'default';	
#			$tpage = $page ne '' ? $page : 'misc';
#		} else {
#			usage('There was an error saving the template.');
#		}
#
#		print "opening $tmpfile\n";
#		open(FILE, "<$tmpfile");
#		{ local $/; $data = <FILE> }
#		close(FILE);
#
#		if($tpid) {
#			$tmp = $slash->getTemplate($tpid);
#			if ($tmp && $tmp->{tpid} == $tpid) {
#				$exists = 1 ;
#				$tname = $name eq '' ? $tmp->{name} : $name ;
#				$tpage = $page eq '' ? $tmp->{page} : $page ;
#				$tsection = $section eq '' ? $tmp->{section} : $section ;
#			}
#			
#		} else {
#			if ($filename_flag && $dirflag) {
#				$tmp = $slash->getTemplateByName($tname, [ 'section','page','name','tpid' ], 1 ,$ppage,$psection);
#				if (	$tmp &&
#					$tmp->{page} eq $ppage && 
#					$tmp->{section} eq $psection && 
#					$tmp->{name} eq $pname ) 
#				{
#					$exists = 1; 
#				}
#			} else {
#				$tmp = $slash->getTemplateByName($tname, [ 'section','page','name','tpid' ], 1, $tpage,$tsection);
#				if (	$tmp &&
#					$tmp->{page} eq $tpage && 
#					$tmp->{section} eq $tsection && 
#					$tmp->{name} eq $tname ) 
#				{
#					$exists = 1; 
#				}
#			}
#
#		}
#
#		if($exists) {
#			print "updating $tname, tpid $tmp->{tpid}\n";
#			$slash->setTemplate($tmp->{tpid}, { 	
#						page 	=> $tpage,
#						section => $tsection,
#						template => $data 
#						});
#		} else {
#			print "creating $tname\n";
#			my $seclev = 100;
#			$slash->createTemplate({ tpid		=> '',
#						name 		=> $tname,
#						page 		=> $tpage,
#						section		=> $tsection,
#						template	=> $data,
#						seclev		=> $seclev
#						});
#		}
#	}
#}

###############################################
sub dump_templates {
	my ($templatelist, $directory) = @_;
	my $filename;

	for my $template (keys %$templatelist) {
		if (! $directory || -d $directory) {
			$filename = $templatelist->{$template}{'name'} . ';' .  
				$templatelist->{$template}{'page'} . ';' .  
				$templatelist->{$template}{'section'};

			$filename = $directory . "/" . $filename;
		} else {
			$filename = $directory;
		} 

		print "dumping template to $filename\n";

		$install->writeTemplateFile($filename, $templatelist->{$template});
	} 
}

###############################################
sub list_templates {
	my ($templatelist, $file) = @_;

	if($file) {	
		$file .= $file . '/templatelist.txt' if -d $file;

		print "printing template descriptions to $file\n";
		open(FILE, ">$file") or die "$! unable to open file $file to dump to\n";
		select(FILE);
	}

	for my $template (keys %$templatelist) {

		# stinking lousy control-Ms
		$templatelist->{$template}{description} =~ s/\x0d//g if $templatelist->{$template}{description};

		print <<EOT; 
--------------------------------------------------------
Tpid: $templatelist->{$template}{tpid} Name: $templatelist->{$template}{name}
Page: $templatelist->{$template}{section} Section: $templatelist->{$template}{page}

EOT

		print <<EOT if $templatelist->{$template}{description};
Description:\n$templatelist->{$template}{description}
EOT
	}

	close(FILE);
}
###############################################
sub delete_templates {
	my ($templatelist) = @_;
	my $list = join(" ",keys(%$templatelist));
	print "are you sure you want to delete templates tpid(s) $list ? y/Y ";
	my $answer = <STDIN>;
	chomp($answer);
 
	if($answer eq 'Y' || $answer eq 'y') { 
		for my $template (keys %$templatelist) {
			$slash->deleteTemplate($template);
		}
	} else {
		print "\n...canceled template deletion.\n";
	}
}

###############################################
sub compile_template {
	# at some point, it would probably be best to get the
	# template object from Slash::Display.  we should talk
	# more about this.  -- pudge
	# Reproduce Slash::Display environment while adding our own options.
	require Slash::Display;				# could just duplicate $filters.
	require Slash::Display::Provider;			

	my $template_provider = Slash::Display::Provider->new({
		TRIM 		=> 1,
		PRE_CHOMP 	=> 1,
		POST_CHOMP	=> 1,
		COMPILE_EXT	=> '.ttc',
		COMPILE_DIR	=> $opts{O} || '.',
	});

	require Template::Stash;

	my %list_ops = ( 
		'rand' => sub {
			my $list = shift;
			return $list->[rand @$list];
		}
	);

	my %scalar_ops = (
        'uc'		=> sub { uc $_[0] },
        'lc'		=> sub { lc $_[0] },
        'ucfirst'	=> sub { ucfirst $_[0] },
        'lcfirst'	=> sub { lcfirst $_[0] },
	);

	@{$Template::Stash::LIST_OPS}  {keys %list_ops}   = values %list_ops;
	@{$Template::Stash::SCALAR_OPS}{keys %scalar_ops} = values %scalar_ops;

	my $page = $opts{P} || 'misc';
	my $section = $opts{S} || 'default';

	for (@ARGV) {
		my($data, $template, $compiled_template, $error);

		if ($opts{i}) {
			$template = $slash->getTemplate($_, 'template');
		} elsif ($opts{f}) {
			# The logic here is that $template would be set to the contents
			# of the file named $_.
			local $/ = undef;
			if (open(INFILE, "$_")) {
				$template = <INFILE>;
				close(INFILE);
			} else {
				print "Can't open file $_ for reading: $!\n";
			}
		} else {
			$template = $slash->getTemplateByName(	$_, 'template', 0,
													$page, $section );
		}
		die "Requested template '${_}' (${section}|$page) is empty!\n"
			if !$template;

		# Load us a custom \%data for compilation.
		$data = {
			text	=> $template,
			name	=> $_,
			time	=> 0,
			load	=> 0,
		};
		# Now perform the actual compilation...
		# -- Yes, Krow. I know I'm not supposed to access private members this 
		# way, but I'm being quick'n'dirty here.
		($compiled_template, $error) =
			$template_provider->_compile($data, "${_}_${section}_$page.ttc");
		print "ERROR: $error\n" if $error;
	}
}

###############################################
sub usage {
	my ($message) = @_;
	print "ERROR: $message\n";
	print <<EOT;
Usage: template-tool [OPTIONS] <template templateN>

OPTIONS

	-d dump templates
	-i use tpid (template id) instead of template name

	-l list template(s) and their descriptions
	-p only perform list and get actions if the template matches this pattern
	-f <templatefilename> filename of template being dumped or created (single template)
	
	-s create/save/update template 

	-D directory where templates are saved or created
	-P <page> template page
	-S <section> template section

	Save Notes:
	* With no args except filename, uses template name to derive section, 
	page and template name from.
	* -s <filenames> allows you to save specific 
	templates from the given files. This needs to be a template in a
	template file format. Use -b to generate blank ones.
	* If you don't supply a template name, or leave the section and page 
	unset, the name will try to be derived from the filename.
	* If you supply a section and/or page and your reading files out of a 
	directory, those templates will be saved with those sections. If you 
	want to read from a directory and not have your section or page changed,
	don't provide these arguments.

	-r deletes template(s) (don't shoot yourself in the foot!)
	-u virtual user to use(default is slash)
	-? this message

Section, page, and template args logic:

	for listing and dumping functions:

	-S <section> all templates in a section
	-S <section> <template templateN> all templates in a section having the name(s)
	-P <page> all templates for a page
	-P <page> <template templateN> all templates for a page having the name(s)
	-S <section> -P <page> all templates for a page and section
	-S <section> -P <page> <template templateN> templates for a page and 
	section with the name(s) <template templateN> all templates having the 
	name(s) all other template fields should be modified via web interface

Debugging options:

	-c Compiles named template into Perl code for testing.
	-O <directory> Destination directory of compiled templates (default=.)

	Compiled templates are saved as <template-name>.ttc in the destination
	directory.

	-v Version of this program
EOT
	exit();
}

